1. подмножества языка sql
язык sql делится на группы команд по их функциональному назначению:

    ddl (data definition language) — создание и изменение структуры объектов: create, alter, drop
    dml (data manipulation language) — работа с данными внутри таблиц: select, insert, update, delete
    dcl (data control language) — управление правами доступа: grant, revoke
    tcl (transaction control language) — управление транзакциями: commit, rollback

2. реляционные базы данных. основные понятия
реляционная модель предполагает хранение данных в виде взаимосвязанных таблиц. основные элементы включают сущность (таблицу), атрибут (столбец) и кортеж (строку). связи между таблицами устанавливаются через ключи, а структура данных описывается логической схемой

3. атрибуты столбца в sql
при определении столбца в таблице задаются его технические характеристики: тип данных, обязательность заполнения (not null), уникальность значений (unique) и автоматическое значение при добавлении строки (default)

4. основные типы данных
в стандартном sql выделяют следующие типы:

    числовые: integer, decimal(p,s) для точных финансовых расчетов
    строковые: varchar(n) для переменной длины и char(n) для фиксированной
    дата и время: date, time, timestamp
    логический: boolean (принимает значения true или false)

5. соединения в sql
соединения используются для связывания данных из двух и более таблиц на основе общего поля. инструкции соединения прописываются в блоке from с использованием ключевого слова join и условия сопоставления строк on

6. первичный ключ
первичный ключ (primary key) — это уникальный идентификатор записи в таблице. он должен быть уникальным для каждой строки и не может содержать значение null. в одной таблице может быть определен только один первичный ключ

7. ограничения (constraints)
это специальные правила, которые система проверяет при любых изменениях данных: primary key (уникальность и наличие), foreign key (связь с другой таблицей), unique (уникальность), not null (обязательность) и check (логическая проверка условия)

8. первая нормальная форма
1нф требует, чтобы каждое поле в таблице было атомарным. это означает, что в одной ячейке должно храниться только одно значение, а использование массивов или списков внутри поля запрещено

9. вторая нормальная форма
2нф требует соблюдения условий 1нф и того, чтобы каждый неключевой столбец зависел от всего первичного ключа целиком. это исключает частичную зависимость данных в таблицах с составными ключами

10. третья нормальная форма
3нф требует соблюдения 2нф и отсутствия транзитивных зависимостей. это означает, что неключевые столбцы должны зависеть только от первичного ключа, а не от других неключевых полей

11. нормальная форма бойса-кодда
бкнф является более строгим вариантом 3нф. она требует, чтобы в таблице любой определитель (атрибут, от которого зависят другие данные) являлся потенциальным ключом этой таблицы

12. этапы проектирования бд
процесс начинается с концептуального проектирования (определение сущностей и связей), переходит в логическое проектирование (формирование таблиц и ключей) и завершается физическим проектированием (настройка типов данных и индексов)

13. внешний ключ (foreign key)
это поле в таблице, которое ссылается на первичный ключ в другой таблице. внешний ключ обеспечивает ссылочную целостность, гарантируя, что связанные данные действительно существуют в родительской таблице

14. типы соединений таблиц

    inner join — возвращает только те строки, которые имеют совпадения в обеих таблицах
    left join — возвращает все строки из левой таблицы и совпадения из правой
    right join — возвращает все строки из правой таблицы и совпадения из левой
    full join — возвращает вообще все строки из обеих таблиц при наличии совпадений
    cross join — создает декартово произведение, соединяя каждую строку первой таблицы с каждой строкой второй

15. обработка ошибок в sql
стандартный sql предполагает обработку исключений через механизм sqlstate. в современных системах для этого обычно используются блоки try...catch, позволяющие перехватить ошибку и выполнить альтернативный код

16. работа со значениями null
null означает отсутствие значения или неизвестность. для проверки поля на пустоту нельзя использовать оператор =, необходимо использовать конструкции is null или is not null. для замены пустоты значением используется функция coalesce

17. подзапросы в sql
это запросы, которые вложены в основную команду. скалярные подзапросы возвращают одно значение для сравнения, а табличные подзапросы возвращают набор строк для использования с операторами in, any, all или exists

18. временные таблицы
это объекты для временного хранения данных в рамках сессии или транзакции. стандартная команда выглядит так:
create global temporary table temp_name (id integer)
данные в таких таблицах исчезают после завершения работы пользователя

19. табличные пользовательские функции
эти функции возвращают результат в виде набора строк. их можно подставлять в блок from и обращаться к ним так же, как к обычным таблицам или представлениям

20. использование псевдонимов (aliases)
псевдонимы создаются с помощью ключевого слова as. они позволяют давать временные короткие имена таблицам или более понятные заголовки столбцам в итоговом наборе данных

21. сохранение результата запроса в таблицу
стандартный способ создать новую таблицу и сразу наполнить её данными из запроса выглядит так:
create table new_table as select * from old_table

22. изменение данных и объектов бд
для изменения значений в строках используется update. для модификации структуры уже существующей таблицы (например, добавления колонки) применяется команда alter table

23. агрегатные функции
функции для вычислений над группой строк: count (подсчет количества), sum (сумма), avg (среднее значение), min (минимум) и max (максимум)

24. оконные функции
выполняют расчеты по набору строк, связанных с текущей записью, без схлопывания результата в одну строку. используют синтаксис over (partition by ... order by ...). примеры: row_number(), rank(), sum() over()

25. скалярные пользовательские функции
это функции, принимающие входные параметры и возвращающие ровно одно значение определенного типа, которое можно использовать в выражениях select или where

26. фильтрация данных в запросах
фильтрация отдельных строк выполняется через where до выполнения агрегации. фильтрация уже сгруппированных данных по результатам функций выполняется через having

27. команды для работы с данными в sql
основной набор команд для манипуляции информацией (dml) состоит из четырех инструкций: select, insert, update и delete

28. работа с переменными в sql
в процедурных расширениях sql переменные используются для хранения промежуточных данных. объявление переменной обычно выглядит так:
declare var_name integer;

29. представления (view)
это виртуальные таблицы, которые представляют собой сохраненный запрос. они не хранят данные сами по себе, а вычисляют результат заново при каждом обращении пользователя

30. способы избавления от повторяющихся записей
наиболее распространенный метод — использование ключевого слова distinct сразу после select. также для удаления дублей можно использовать группировку group by по всем выбранным полям

31. хранимые процедуры
это скомпилированные блоки кода с логикой, которые хранятся на сервере. они могут принимать параметры, возвращать данные и выполнять последовательности dml и ddl команд

32. использование insert, update и delete внутри функций
в стандартных пользовательских функциях обычно запрещено изменять состояние базы данных командами insert, update или delete. функции предназначены только для вычислений и возврата данных

33. использование подзапросов в операторах сравнения
подзапрос может стоять справа от операторов =, >, <. условием работы является то, что такой подзапрос должен возвращать ровно одну строку с одним столбцом

34. группировка в запросах
реализуется через group by. этот оператор разделяет данные на группы по значениям в указанных столбцах, чтобы применить к каждой группе агрегатные функции

35. функция count()
используется для подсчета записей. count(*) считает все строки в наборе, а count(имя_столбца) считает только те строки, где в данном поле нет значения null

36. операторы работы с множествами
команды для комбинирования результатов запросов:

    union — объединение наборов (удаляет дубликаты)
    intersect — возвращает только те строки, которые есть в обоих наборах
    except — возвращает строки первого набора, которых нет во втором

37. функции ранжирования
вид оконных функций. row_number() дает уникальный номер каждой строке, rank() присваивает ранг с пропусками при совпадениях, dense_rank() присваивает ранг без пропусков номеров

38. команды ddl
основной набор для управления схемой данных: create (создание), alter (изменение), drop (удаление объекта) и truncate (быстрая очистка данных в таблице)

39. виды ключей в реляционных субд
помимо первичного (pk) и внешнего (fk), существуют потенциальные ключи (кандидаты на pk) и составные ключи, состоящие из нескольких столбцов таблицы

40. связанные таблицы
таблицы соединяются на основе отношений: один-ко-многим (самый частый вид), один-к-одному или многие-ко-многим. последняя связь реализуется через вспомогательную таблицу со ссылками

41. ограничения уникальности
ограничение unique гарантирует, что значения в столбце не будут повторяться. в отличие от первичного ключа, таких ограничений в таблице может быть несколько, и они могут разрешать null

42. удаление данных и объектов бд
удаление строк из таблицы выполняется через delete. полное удаление объекта (таблицы) из базы данных выполняется командой drop table. очистка данных без удаления самой структуры — truncate

43. оператор объединения
оператор union склеивает результаты двух запросов select. обязательным условием является одинаковое количество столбцов и совместимость их типов данных в обоих запросах

44. типы пользовательских функций
функции классифицируются по результату: скалярные (одно значение), табличные (набор строк) и агрегатные (вычисление по набору данных)

45. способы возврата данных из хранимой процедуры
процедуры возвращают информацию через результирующие наборы строк (select), специальные выходные параметры (output) или целочисленные коды возврата

46. полный синтаксис команды select
логическая структура запроса выглядит так:
select [distinct] поля from таблицы join связи where фильтры_строк group by поля_группировки having фильтры_групп order by сортировка

47. полный синтаксис команды insert
добавление новых записей:
insert into имя_таблицы (столбец1, столбец2) values (значение1, значение2)

48. полный синтаксис команды update
модификация существующих записей:
update имя_таблицы set столбец1 = значение1 where условие_фильтрации

49. полный синтаксис команды delete
удаление строк:
delete from имя_таблицы where условие_фильтрации

50. обобщенные табличные выражения (cte)
позволяют определить временный именованный результирующий набор прямо перед выполнением основного запроса:
with cte_name as (select * from table) select * from cte_name

51. функции для работы со значениями datetime
стандартные средства включают получение системного времени через current_date или current_timestamp, а также извлечение частей даты через оператор extract

52. количество строк в результате соединений
при inner join строк не больше, чем в наибольшей таблице. при left join количество строк не меньше, чем в левой таблице. при cross join количество строк равно произведению строк обеих таблиц

53. действия при изменении родительской таблицы
внешний ключ может настраиваться правилами: on delete cascade (удалить связанные), on delete set null (установить пустоту) или запретить действие через restrict

54. оператор case
позволяет реализовать логику ветвления внутри запроса:
case when условие then результат else альтернатива end

55. вызов пользовательских функций
скалярные функции вызываются внутри списка полей select или в фильтрах. табличные функции вызываются в предложении from наравне с обычными таблицами

56. вызов хранимой процедуры
в стандартном sql процедура запускается командой call:
call имя_процедуры(аргументы)

58. извлечение диапазона строк
для выборки части данных (пагинации) в стандартном sql используется конструкция в самом конце запроса:
offset 10 rows fetch next 10 rows only
